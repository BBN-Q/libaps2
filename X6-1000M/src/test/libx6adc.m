function [methodinfo,structs,enuminfo,ThunkLibName]=libx6adc
%LIBX6ADC Create structures to define interfaces found in 'libx6adc'.

%This function was generated by loadlibrary.m parser version 1.1.6.38 on Tue Dec 17 10:24:56 2013
%perl options:'libx6adc.i -outfile=libx6adc.m -thunkfile=libx6adc_thunk_pcwin64.c -header=libx6adc.h'
ival={cell(1,0)}; % change 0 to the actual number of functions to preallocate the data.
structs=[];enuminfo=[];fcnNum=1;
fcns=struct('name',ival,'calltype',ival,'LHS',ival,'RHS',ival,'alias',ival,'thunkname', ival);
MfilePath=fileparts(mfilename('fullpath'));
ThunkLibName=fullfile(MfilePath,'libx6adc_thunk_pcwin64');
%  int init (); 
fcns.thunkname{fcnNum}='int32Thunk';fcns.name{fcnNum}='init'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
%  int connect_by_ID ( int ); 
fcns.thunkname{fcnNum}='int32int32Thunk';fcns.name{fcnNum}='connect_by_ID'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32'};fcnNum=fcnNum+1;
%  int disconnect ( int ); 
fcns.thunkname{fcnNum}='int32int32Thunk';fcns.name{fcnNum}='disconnect'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32'};fcnNum=fcnNum+1;
%  int get_num_devices (); 
fcns.thunkname{fcnNum}='int32Thunk';fcns.name{fcnNum}='get_num_devices'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
%  int initX6 ( int ); 
fcns.thunkname{fcnNum}='int32int32Thunk';fcns.name{fcnNum}='initX6'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32'};fcnNum=fcnNum+1;
%  int read_firmware_version ( int ); 
fcns.thunkname{fcnNum}='int32int32Thunk';fcns.name{fcnNum}='read_firmware_version'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32'};fcnNum=fcnNum+1;
%  int set_digitizer_mode ( int , int ); 
fcns.thunkname{fcnNum}='int32int32int32Thunk';fcns.name{fcnNum}='set_digitizer_mode'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32', 'int32'};fcnNum=fcnNum+1;
%  int get_digitizer_mode ( int ); 
fcns.thunkname{fcnNum}='int32int32Thunk';fcns.name{fcnNum}='get_digitizer_mode'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32'};fcnNum=fcnNum+1;
%  int set_sampleRate ( int , double ); 
fcns.thunkname{fcnNum}='int32int32doubleThunk';fcns.name{fcnNum}='set_sampleRate'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32', 'double'};fcnNum=fcnNum+1;
%  double get_sampleRate ( int ); 
fcns.thunkname{fcnNum}='doubleint32Thunk';fcns.name{fcnNum}='get_sampleRate'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='double'; fcns.RHS{fcnNum}={'int32'};fcnNum=fcnNum+1;
%  int set_trigger_source ( int , int ); 
fcns.thunkname{fcnNum}='int32int32int32Thunk';fcns.name{fcnNum}='set_trigger_source'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32', 'int32'};fcnNum=fcnNum+1;
%  int get_trigger_source ( int ); 
fcns.thunkname{fcnNum}='int32int32Thunk';fcns.name{fcnNum}='get_trigger_source'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32'};fcnNum=fcnNum+1;
%  int set_averager_settings ( int , int , int , int , int ); 
fcns.thunkname{fcnNum}='int32int32int32int32int32int32Thunk';fcns.name{fcnNum}='set_averager_settings'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32', 'int32', 'int32', 'int32', 'int32'};fcnNum=fcnNum+1;
%  int acquire ( int ); 
fcns.thunkname{fcnNum}='int32int32Thunk';fcns.name{fcnNum}='acquire'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32'};fcnNum=fcnNum+1;
%  int wait_for_acquisition ( int , int ); 
fcns.thunkname{fcnNum}='int32int32int32Thunk';fcns.name{fcnNum}='wait_for_acquisition'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32', 'int32'};fcnNum=fcnNum+1;
%  int stop ( int ); 
fcns.thunkname{fcnNum}='int32int32Thunk';fcns.name{fcnNum}='stop'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32'};fcnNum=fcnNum+1;
%  int transfer_waveform ( int , int , short *, unsigned int ); 
fcns.thunkname{fcnNum}='int32int32int32voidPtruint32Thunk';fcns.name{fcnNum}='transfer_waveform'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32', 'int32', 'int16Ptr', 'uint32'};fcnNum=fcnNum+1;
%  int set_log ( char *); 
fcns.thunkname{fcnNum}='int32cstringThunk';fcns.name{fcnNum}='set_log'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'cstring'};fcnNum=fcnNum+1;
% int update_log ( FILE * pFile ); 
fcns.thunkname{fcnNum}='int32voidPtrThunk';fcns.name{fcnNum}='update_log'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'s_iobufPtr'};fcnNum=fcnNum+1;
%  int set_logging_level ( int ); 
fcns.thunkname{fcnNum}='int32int32Thunk';fcns.name{fcnNum}='set_logging_level'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32'};fcnNum=fcnNum+1;
%  int read_register ( int , int , int ); 
fcns.thunkname{fcnNum}='int32int32int32int32Thunk';fcns.name{fcnNum}='read_register'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32', 'int32', 'int32'};fcnNum=fcnNum+1;
%  int write_register ( int , int , int , int ); 
fcns.thunkname{fcnNum}='int32int32int32int32int32Thunk';fcns.name{fcnNum}='write_register'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32', 'int32', 'int32', 'int32'};fcnNum=fcnNum+1;
%  float get_logic_temperature ( int , int ); 
fcns.thunkname{fcnNum}='floatint32int32Thunk';fcns.name{fcnNum}='get_logic_temperature'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='single'; fcns.RHS{fcnNum}={'int32', 'int32'};fcnNum=fcnNum+1;
structs.s_iobuf.packing=8;
structs.s_iobuf.members=struct('m_ptr', 'cstring', 'm_cnt', 'int32', 'm_base', 'cstring', 'm_flag', 'int32', 'm_file', 'int32', 'm_charbuf', 'int32', 'm_bufsiz', 'int32', 'm_tmpfname', 'cstring');
enuminfo.X6ErrorCode=struct('X6_OK',0,'X6_UNKNOWN_ERROR',-1,'X6_BUFFER_OVERFLOW',-2,'X6_NOT_IMPLEMENTED_ERROR',-3,'X6_INVALID_CHANNEL',-4,'X6_FILE_ERROR',-5,'X6_INVALID_DEVICEID',-6,'X6_TIMEOUT',-7);
methodinfo=fcns;